# ED - FSM Framework for ARM Cortex-M Series

Welcome to the ED-FSM Framework for ARM Cortex-M microcontrollers. This framework is designed to simplify the development of event-driven applications, making your embedded systems more efficient and responsive.

## Introduction to Event-Driven Programming

Event-driven programming is a paradigm where the program's execution flow is dictated by events, such as ADC conversion completion, UART data reception, sensor outputs, and so on. An event-driven system constantly monitors incoming events and dispatches them to the appropriate handlers.

   ### Key Concepts
   
   1. **Event**: A detectable occurrence or action that the system can respond to, such as hardware interrupts, timer overflows, or custom user-defined events.
      
   2. **Event Handler**: A function or method that executes in response to a specific event, containing the logic needed to process it.
   
   3. **Event Queue**: A data structure that temporarily stores events until they are processed by an event handler. Events are typically handled in the order they arrive (FIFO – First In, First Out).
   
   4. **Dispatcher**: A component that monitors the event queue and invokes the appropriate event handler when an event is detected.

   ### How It Works
   
   The following diagram illustrates the basic workflow of an event-driven system:
   
   ![image](https://github.com/user-attachments/assets/89739d51-996a-4b5d-98b2-9eb4bca0734f)
   
   1. Events are generated by the system, there are 3 sources of events:
      - **Interrupts Events**: Event come from ISR such as GPIO, ADC, UART, SPI, I2C, ... (E1, E2, E4)
      - **Timer Events**: Events come from Timer such as Systick, HardTimer, SoftTimer (E3, E7)
      - **Custom Events**: Events come from another handler function (E5, E6)
   2. Events are pushed into the event queue.
   3. The dispatcher fetches events from the event queue.
   4. The dispatcher invokes the corresponding event handler for each event.
   
   > **Note:** All steps 3 and 4 are performed inside the Engine module.

   ### Advantages
   
   - **Modularity**: Event-driven systems enhance modularity by decoupling event detection from event handling, making the system easier to maintain and extend.
   - **Responsiveness**: The system can quickly react to asynchronous events, improving real-time performance.
   - **Scalability**: New event types and handlers can be added with minimal impact on existing code, making the system highly extensible

## Framework Features

- **Lightweight**: Optimized for minimal resource usage, making it ideal for embedded systems with limited memory and processing power.
- **Flexible**: Supports user-defined event types and handlers, allowing customization based on application needs.
- **Efficient**: Fine-tuned for ARM Cortex-M microcontrollers, ensuring low latency and fast event processing.

## Framework Note

- **Best suited for bare-metal systems:** This framework is designed for systems running without an operating system (RTOS).

- **Idle behavior:** When no events are pending, the system executes WAIT FOR INTERRUPT (WFI) to reduce power consumption and improve efficiency.

- **Non-blocking execution:** The framework follows an asynchronous, non-blocking approach to ensure smooth event processing

## Important Considerations

- This framework follows a cooperative (non-preemptive) execution model, meaning it does not support priorities or context switching. Event handlers are executed sequentially in the order they are received.

- Since there is no preemption, each handler must complete its execution before the next event can be processed. Therefore, it is crucial to keep handler execution time minimal to ensure fast response to new events. Long-running operations within handlers may delay event processing and degrade system responsiveness.

- Additionally, for microcontrollers with a single core, the system operates within a single main loop. Blocking functions (e.g., HAL_Delay(), while (!UART_Ready()), etc.) should be avoided, as they can halt event processing and introduce latency. Always consider the impact of such functions on event queue performance and overall system behavior.**

<p><em><strong><span style="font-size: 1.5em;">Refer to the <span style="text-decoration: underline;">guide-line</span> directory for documentation on how to use the framework’s macro functions.</span></strong></em></p>

